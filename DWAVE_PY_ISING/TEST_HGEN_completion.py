"""
-------------------------------------------------------------------------------
Created on Wed Jul 20 2018
author: Suksmono@{STEI-ITB, MDR Inc.}
Find a Hadamard matrix using QA Computer/DWave
-------------------------------------------------------------------------------
**** HADAMARD MATRIX COMPLETION PROBLEM ****
P: Given N-orthogonal binary vectors of length M>N,
   find (M-N) vectors that complete M-orthoset to become a H-matrix
-------------------------------------------------------------------------------
"""
from sympy import *
from prb_symbolic import *
import neal
import numpy as np

# define matrix order
#M=8 
# define number of sweeps/iteration
# move here to conform the problem size
NSWEEPS=1*1*1*1000


"""
-------------------------------------------------------------------------------
DEFINE KNOWN ORTHO-VECTORS
-------------------------------------------------------------------------------
"""

'''
# 4x4
# ------------------------------------------
sk4=[  [1, 1, 1, 1] ,\
      [1,-1, 1,-1]]
# ------------------------------------------
# 8x8
# ------------------------------------------
sk8=[[ 1, 1, 1, 1, 1, 1, 1, 1], \
    [ 1,-1, 1,-1, 1,-1, 1,-1], \
    [ 1, 1,-1,-1, 1, 1,-1,-1], \
    [ 1, 1, 1, 1,-1,-1,-1,-1], \
    [ 1,-1,-1, 1, 1,-1,-1, 1], \
    [ 1, 1,-1,-1,-1,-1, 1, 1] \
    ]
# missing vector(s)
 [ 1,-1, 1,-1,-1, 1,-1, 1], \
'''
# 12x12
# source: matlab generated
# ------------------------------------------
sk12=[ \
     [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], \
     [ 1,-1, 1,-1, 1, 1, 1,-1,-1,-1, 1,-1], \
     [ 1,-1,-1, 1,-1, 1, 1, 1,-1,-1,-1, 1], \
     [ 1, 1,-1,-1, 1,-1, 1, 1, 1,-1,-1,-1], \
     [ 1,-1, 1,-1,-1, 1,-1, 1, 1, 1,-1,-1], \
     [ 1,-1,-1, 1,-1,-1, 1,-1, 1, 1, 1,-1], \
     [ 1,-1,-1,-1, 1,-1,-1, 1,-1, 1, 1, 1], \
     [ 1, 1,-1,-1,-1, 1,-1,-1, 1,-1, 1, 1], \
     [ 1, 1, 1, 1,-1,-1,-1, 1,-1,-1, 1,-1], \
     [ 1,-1, 1, 1, 1,-1,-1,-1, 1,-1,-1, 1], \
     [ 1, 1,-1, 1, 1, 1,-1,-1,-1 ,1,-1,-1]  \
   ]

'''
# missing vector(s)
     [ 1, 1, 1,-1,-1,-1, 1,-1,-1, 1,-1, 1], \
'''


# 28x28
# source http://neilsloane.com/hadamard/had.28.pal2.txt
# Paley-2
sk28=[ \
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1], \
    [1,1,1,-1,1,1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,1,1,-1,-1,-1,-1,1,1,-1,1], \
    [1,1,1,1,-1,1,1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,1,1,-1,-1,-1,-1,1,1,-1], \
    [1,-1,1,1,1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,1,1], \
    [1,1,-1,1,1,1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,1], \
    [1,1,1,-1,1,1,1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1], \
    [1,-1,1,1,-1,1,1,1,-1,1,1,-1,-1,-1,1,-1,1,1,-1,1,-1,1,-1,1,1,-1,-1,-1], \
    [1,-1,-1,1,1,-1,1,1,1,-1,1,1,-1,-1,1,-1,-1,1,1,-1,1,-1,1,-1,1,1,-1,-1], \
    [1,-1,-1,-1,1,1,-1,1,1,1,-1,1,1,-1,1,-1,-1,-1,1,1,-1,1,-1,1,-1,1,1,-1], \
    [1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,1,1], \
    [1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,1], \
    [1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1], \
    [1,-1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,1,1,-1,1,-1,1], \
    [1,1,-1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,1,1,-1,1,-1], \
    [-1,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1], \
    [1,-1,1,-1,1,1,-1,-1,-1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,-1,-1,1,-1], \
    [1,1,-1,1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,-1,-1,1,1,1,1,-1,-1,1], \
    [1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,-1,-1], \
    [1,1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,-1], \
    [1,1,1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1], \
    [1,-1,1,1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,1,1,1], \
    [1,-1,-1,1,1,-1,1,-1,1,-1,1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,-1,1,1], \
    [1,-1,-1,-1,1,1,-1,1,-1,1,-1,1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,-1,1,-1,-1,1], \
    [1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,-1,-1,1,-1,-1,-1,1,-1,-1], \
    [1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,-1,1,-1], \
    [1,1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,-1,1], \
    [1,1,-1,1,1,-1,-1,-1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,-1,-1,1,-1,-1] \
    ]
#
'''
# missing vector(s)
    [1,-1,1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,-1], \
'''

sk=sk12 #sk28
[NC, M]=np.shape(sk)
#
NO= M-NC    # number of known vector
# number of required qubits
NQ=M*NO + M*int(NO*(NO-1)/2)

'''
-------------------------------------------------------------------------------
1. Formulate Hks
-------------------------------------------------------------------------------
'''

ss=symbols('s0:%d'%NQ)
qq=symbols('q0:%d'%NQ)

'''
-------------------------------------------------------------------------------
generate s and q matrix
-------------------------------------------------------------------------------
 |<---problem-->|<------ ancillas ------>|
-------------------------------------------------------------------------------
  s0 s4   1  1  |s8 
  s1 s5  -1  1  |s9 
  s2 s6   1  1  |s10 
  s3 s7  -1  1  |s11 
--------------------------------------------------------------------------------------------------------------------------------------------------------------
'''

s,q=gen_csqmatrix(M,NQ,sk)
'''
-------------------------------------------------------------------------------
calculate Hks
-------------------------------------------------------------------------------
'''

print('Calculating Hks ...')

Hks=formHks(M,s)
'''
---------------------------------------------------
simplify by substition of all si**2 terms: si**2->1
---------------------------------------------------
'''

print('Substitution of si**2->1 ...')
Hks=rmvIdSquareNEW(Hks,ss)


'''
-------------------------------------------------------------------------------
2. Transform Hks -> Hkq
-------------------------------------------------------------------------------
'''

print('Transform: Hks->Hkq ...')
Hkq=Hks2HkqNEW(Hks, ss, qq)

'''
-------------------------------------------------------------------------------
2. Transform Hkq -> H2q -> H2s
-------------------------------------------------------------------------------
'''

'''
---------------------------------------------------
 define rows of substitution pair [i,j,k]: qi*qj->qk
---------------------------------------------------
'''

spair=genSubsPairNEW(M,NO)

#
#[NPAIR, XX]=np.shape(spair)
dijMax=M*M #**2
#HMax=NPAIR*dijMax
HMax=dijMax
delta=2*HMax #6*16 #2*NPAIR*M #2*(M**2)
print('Transform: Hkq->H2q->H2s ...')
H2q, H2s = q2s_symbolig(Hkq, q, s, spair, delta)

print('H2q:\n', H2q)
print('H2s:\n', H2s)

'''
------------------------------------------------------------
3. EXTRACT ISING PARAMETERS FROM SYMBOLIC SOLUTION
------------------------------------------------------------
'''
print('Obtaining Ising coefficients ...')
b, hi, Jij = isingCoeffs(H2s,NQ)


# normalize coefficients
maxCoeff=np.max([np.max(abs(hi)), np.max(abs(Jij))])
hi=hi/maxCoeff
Jij=Jij/maxCoeff
#
b=b/maxCoeff
'''
-----------------------------------------------------------------------------
convert the problem into Ising coefficients
-----------------------------------------------------------------------------
'''
#in dictionary format
h={0:0}
J={(0,1):1}

for m in range(0,len(hi)):
    h[m]=hi[m]
    for n in range (m+1,len(hi)):
        J[m,n]=Jij[m,n]
    
'''
-----------------------------------------------------------------------------
4. SOLVE THE PROBLEM
-----------------------------------------------------------------------------
select a solver
> dimod: ExaxtSolver
> neal:  SimulatedAnnealingSampler
'''
#
print('Solving the problem using neal  ...')
#### add timing
import time
t0 = time.time()
##
solver=neal.SimulatedAnnealingSampler()
#NSWEEPS=1*1*10*10*1000
response = solver.sample_ising(h, J, sweeps=NSWEEPS, num_reads=4)
#
#
t1=time.time()
elapsed = t1 -t0
print('(simulated) annealing time = ', elapsed)
#
print('t0 = ', t0)
print('t1 = ', t1)
#vE=response.data_vectors['energy']
#aSol=response.samples_matrix
vE=response.record['energy']
aSol=response.record['sample']

#
print('Configurations:\n', aSol)
print('Energy:\n',vE)
#
idxMinE=np.argmin(vE)
print('Minimum Energy:',vE[idxMinE], 'supposed to be', -b)
print('Minimum Configurations:',aSol[idxMinE])
tSol=aSol[idxMinE]
vSol=tSol #[0]
#
HM=vSol[0:M*NO].reshape(NO,M)
print('Found matrix:\n',HM)
print('Indikator sub-matrix:\n', \
       np.matmul(HM.tolist(), HM.transpose().tolist() ))

# full H-matrix
HML=HM.tolist()
for m in range(0,len(sk)):
    HML.append(sk[m])

print('Indikator H-matrix:\n', \
       np.matmul(HML, np.transpose(HML)))
D=np.matmul(HML, np.transpose(HML))
import matplotlib.pyplot as plt
imgplot = plt.imshow(D)
plt.show()
    
print('Number of qubits:', NQ,', number of H2s terms:',\
      len(H2s.as_coefficients_dict()) )
print('number of H2q terms:',\
      len(H2q.as_coefficients_dict()) )
print('number of Hks terms:',\
      len(Hks.as_coefficients_dict()) )
print('number of Hkq terms:',\
      len(Hkq.as_coefficients_dict()) )