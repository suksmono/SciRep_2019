%% -----------------------------------------------------------------------
% Solve H-SEARCH Problem Using DWAVE
% Created by: suksmono@{stei.itb.ac.id, mdrft.com}
% Date: Sept. 2018
%% 
% succesfulll up to 4x4
%% possible solution for higher order cases
% (1) reduce M -> (M-1), consider only normalized or seminormalized H-matrix
% (2) consider only N<M orthoset
% (3) consider H-matrix completion problem
% (4) hybrid classical-quantum method, with random graph construction
% ------------------------------------------------------------------------
clear all; %clc
% Create a local connection
addpath sapi-matlab-client-3.0-win64
addpath functions

%% define problem
% The Ising coefficients are generated by a python script
% to generate Jij file, run python script "TEST_genIsingCoeffs.py" in
%  ...\__Q_2018\__DWave\DWAVE_PY_ISING
%---
M=4;
Jij_DIR='../../Jij_DATA/';
fname=strcat(Jij_DIR, strcat(strcat('Jij_H',int2str(M)), '.txt'));
%
% Number of qubits
NQ=M*M + M*round(M*(M-1)/2);

%% read Jij from file
JH = dlmread(fname);
Jij=zeros(NQ,NQ);
hi=zeros(NQ,1);
for mm=1:NQ
    for nn=mm+1:NQ
        Jij(mm,nn)=JH(mm,nn);
    end
    hi(mm)=JH(mm,mm);
end

%% Chimera structure
SSz=16; %16 ;%4;    %# set 16 for 2048 qubits
MM=SSz;
NN=MM;
L=4;
%%
A=getChimeraAdjacency(MM,NN,L);
embeddings=sapiFindEmbedding(Jij,A,'verbose',1);
% embeddings=sapiFindEmbedding(Jij,A,'verbose',1,'tries', 25);

[hi0,Jij0,Jijc]=sapiEmbedProblem(hi,Jij,embeddings,A);
%% read Jij from unembed structure -> Chimera embedding

F_SUBMIT_PROBLEM=1;
if (F_SUBMIT_PROBLEM==1)
    %% local
    % answer=sapiSolveIsing(solver, hi0, Jij0+Jijc,'num_reads',6);
    %% connect to a server, create a solver
    myUrl='https://your.given.url.by_dwave/';   
    myToken='FILL-IN-YOUR DWAVE TOKEN';   
    myProxy='http://proxy_usr:proxy_passwd@your.proxy. address:port';
    remoteConn = sapiRemoteConnection(myUrl, myToken, myProxy);

    solver = sapiSolver(remoteConn, 'DW_2000Q_VFYC_2_1'); %was: DW_2000Q_VFYC_2
    % Retrieve solver properties from solver
    props = sapiSolverProperties(solver);

    %% Solve an ising problem with optional parameters 'num_reads' and 'num_spin_,!reversal_transforms'
    aconf = sapiSolveIsing(solver,hi0, Jij0+Jijc, 'num_reads', 1000);%, 'num_spin_reversal_transforms', 2)
    newAnswer=sapiUnembedAnswer(aconf.solutions, embeddings,...
        'minimize_energy',hi,Jij);
    %% ****************** try to display
    % display
    x=1:length(aconf.energies);
    figure(11);
    subplot(211);bar(x,aconf.energies,'r')
    xlabel('Solution Id'); ylabel('Energy')
    % figure(2)
    subplot(212);bar(x,aconf.num_occurrences)
    xlabel('Solution Id'); ylabel('Occurence')
    %%%%%%
    %% solutions
    [vEn, idE]=min(aconf.energies);
    % get the solution vector
    sol=newAnswer(:,idE);
    disp(sprintf('Minimum energy: %2.3f', vEn));
    disp(sprintf('H and D matrices'));
    for m=1:M*M
        vH2(m)=sol(m);
    end
    % vH2=[sol(1), sol(2), sol(3), sol(4) ];
    H2=reshape(vH2,M,M);
    D2=H2*transpose(H2);
    %%
    x=1:length(aconf.energies);
%     figure(1);
%     subplot(211);bar(x,aconf.energies,'r')
%     xlabel('Solution Id'); ylabel('Energy')
%     % figure(2)
%     subplot(212);bar(x,aconf.num_occurrences)
%     xlabel('Solution Id'); ylabel('Occurence')
    H2,
    D2,
%  check, how many correct solutions we have
%     probError(aconf,newAnswer);
    probError(aconf,newAnswer,M)
end


